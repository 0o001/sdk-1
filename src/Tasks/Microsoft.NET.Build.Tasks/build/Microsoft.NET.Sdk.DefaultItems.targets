<!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup>
    <EnableDefaultItems Condition=" '$(EnableDefaultItems)' == '' ">true</EnableDefaultItems>
    <EnableDefaultCompileItems Condition=" '$(EnableDefaultCompileItems)' == '' ">true</EnableDefaultCompileItems>
    <EnableDefaultEmbeddedResourceItems Condition=" '$(EnableDefaultEmbeddedResourceItems)' == '' ">true</EnableDefaultEmbeddedResourceItems>
    <EnableDefaultNoneItems Condition=" '$(EnableDefaultNoneItems)' == '' ">true</EnableDefaultNoneItems>
  </PropertyGroup>

  <PropertyGroup>
    <!-- bin folder, by default -->
    <DefaultRemoves>$(DefaultRemoves);$(BaseOutputPath)/**</DefaultRemoves>
    <!-- obj folder, by default -->
    <DefaultRemoves>$(DefaultRemoves);$(BaseIntermediateOutputPath)/**</DefaultRemoves>

    <!-- Various files that should generally always be ignored -->
    <DefaultRemoves>$(DefaultRemoves);**/*.user</DefaultRemoves>
    <DefaultRemoves>$(DefaultRemoves);**/*.*proj</DefaultRemoves>
    <DefaultRemoves>$(DefaultRemoves);**/*.sln</DefaultRemoves>
    <DefaultRemoves>$(DefaultRemoves);**/*.vssscc</DefaultRemoves>
    
    <!-- This pattern is supposed to ignore folders such as .git and .vs, but it would also match items included with a relative path
         outside the project folder (for example "..\Shared\Shared.cs").  So instead of using it to remove from the Compile,
         EmbeddedResource, and Content items in this .targets file, it will be used in the Exclude attribute for the default
         patterns which include files in these items (which happens in Microsoft.NET.Sdk.DefaultItems.props). -->
    <DefaultExcludesInProjectFolder>$(DefaultExcludesInProjectFolder);**/.*/**</DefaultExcludesInProjectFolder>

    <!-- TODO: Verify why this was originally added and whether we really need it -->
    <DefaultRemoves>$(DefaultRemoves);packages/**</DefaultRemoves>
    
  </PropertyGroup>
  
  <ItemGroup Condition="'$(DisableDefaultRemoves)' != 'true'">
    <Compile Remove="$(DefaultRemoves)" />
    <EmbeddedResource Remove="$(DefaultRemoves)" />
    <None Remove="$(DefaultRemoves)" />
    <Content Remove="$(DefaultRemoves)" />
  </ItemGroup>

  <!-- Set the default versions of the NETStandard.Library or Microsoft.NETCore.App packages to reference.
       The implicit package references themselves are defined in Microsoft.NET.Sdk.props, so that they can be overridden
       in the project file. -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(NetStandardImplicitPackageVersion)' == ''">
    <NetStandardImplicitPackageVersion>1.6.1</NetStandardImplicitPackageVersion>
  </PropertyGroup>
  
  <!--
    Determine the NetCoreImplicitPackageVersion and RuntimeFrameworkVersion
    
    The RuntimeFrameworkVersion is the version that is written to the runtimeconfig.json, and is the version of the runtime
    that the app should run on.
    
    If RuntimeFrameworkVersion is not set, then derive the RuntimeFrameworkVersion from the TargetFrameworkVersion,
    and use the latest known version of Microsoft.NETCore.App as the NetCoreAppImplicitPackageVersion, unless that
    property is already set.
    
    If RuntimeFrameworkVersion is set, then use that version for the NetCoreAppImplicitPackageVersion, unless
    NetCoreAppImplicitPackageVersion is already set.
    
  -->

  <Choose>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(RuntimeFrameworkVersion)' == ''">
      <PropertyGroup>
        <!-- Use the version of the framework runtime matching the target framework version-->
        <!-- TODO: Do we upgrade to the latest patch we know about?  Ie if the TargetFrameworkVersion is 1.0, should the
                   RuntimeFrameworkVersion be 1.0.3? -->
        <RuntimeFrameworkVersion>$(_TargetFrameworkVersionWithoutV)</RuntimeFrameworkVersion>
      
        <!-- Normalize RuntimeFrameworkVersion to 3 digits -->
        <RuntimeFrameworkVersion Condition=" $(RuntimeFrameworkVersion.Split('.').Length) == 1">$(RuntimeFrameworkVersion).0.0</RuntimeFrameworkVersion>
        <RuntimeFrameworkVersion Condition=" $(RuntimeFrameworkVersion.Split('.').Length) == 2">$(RuntimeFrameworkVersion).0</RuntimeFrameworkVersion>

        <NetCoreAppImplicitPackageVersion Condition="'$(NetCoreAppImplicitPackageVersion)' == ''">1.1.0</NetCoreAppImplicitPackageVersion>
      </PropertyGroup>
    </When>
    
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(RuntimeFrameworkVersion)' != ''">
      <PropertyGroup>
        <NetCoreAppImplicitPackageVersion Condition="'$(NetCoreAppImplicitPackageVersion)' == ''">$(RuntimeFrameworkVersion)</NetCoreAppImplicitPackageVersion>
      </PropertyGroup>
    </When>
  </Choose>
  
  
  <!-- Remove the implicit PackageReference items if there are non-implicit PackageReference items with the same identity.
       Do this during evaluation instead of adding a target because Visual Studio only uses evaluation to get the
       PackageReferenceitems to restore. -->
  <PropertyGroup Condition="'$(DisableImplicitFrameworkReferences)' != 'true'">
    <_ImplicitPackageName Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">NETStandard.Library</_ImplicitPackageName>
    <_ImplicitPackageName Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">Microsoft.NETCore.App</_ImplicitPackageName>
  </PropertyGroup>
  
  <ItemGroup Condition="'$(_ImplicitPackageName)' != ''">
    <!-- Filter PackageReference to items where the ItemSpec matches the implicit package name, and add IsImplicitlyDefined metadata
         for items that don't have it-->
    <_ImplicitPackageReferenceCheck
        Include="@(PackageReference->WithMetadataValue('Identity', '$(_ImplicitPackageName)'))">
      <IsImplicitlyDefined Condition="'%(IsImplicitlyDefined)' != 'true' ">false</IsImplicitlyDefined>
    </_ImplicitPackageReferenceCheck>
    
    <!-- Now filter down to an item with just the implicit reference and another one with just the overriding reference -->
    <_ImplicitPackageReference Include="@(_ImplicitPackageReferenceCheck->WithMetadataValue('IsImplicitlyDefined', 'true'))"/>
    <_OverridingPackageReference Include="@(_ImplicitPackageReferenceCheck->WithMetadataValue('IsImplicitlyDefined', 'false'))"/>

    <!-- Remove both the implicit and the override item, if there was both an implicit and an override item -->
    <PackageReference Remove="@(PackageReference->WithMetadataValue('Identity', '$(_ImplicitPackageName)'))"
                      Condition="'@(_ImplicitPackageReference)' != '' And '@(_OverridingPackageReference)' != ''"
                      />

    <!-- Add the override item back -->
    <PackageReference Include="@(_OverridingPackageReference)"
                      Condition="'@(_ImplicitPackageReference)' != '' And '@(_OverridingPackageReference)' != ''" />
  </ItemGroup>

  <!-- If an implicit PackageReference was overridden, generate a warning saying that is not typically needed -->
  <Target Name="CheckForImplicitPackageReferenceOverrides" BeforeTargets="_GetRestoreProjectStyle;_CheckForInvalidConfigurationAndPlatform">
    <PropertyGroup>
      <ImplicitPackageReferenceInformationLink>https://aka.ms/sdkimplicitrefs</ImplicitPackageReferenceInformationLink>
    </PropertyGroup>

    <NETSdkError Condition="'@(_ImplicitPackageReference)' != '' And '@(_OverridingPackageReference)' != ''"
                 ResourceName="PackageReferenceOverrideWarning"
                 FormatArguments="$(_ImplicitPackageName);$(ImplicitPackageReferenceInformationLink)"
                 WarningOnly="true"/>
  </Target>

  <UsingTask TaskName="CheckForDuplicateItems" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <Target Name="CheckForDuplicateItems" BeforeTargets="_CheckForInvalidConfigurationAndPlatform">

    <PropertyGroup>
      <DefaultItemsMoreInformationLink>https://aka.ms/sdkimplicititems</DefaultItemsMoreInformationLink>
    </PropertyGroup>

    <CheckForDuplicateItems
      Items="@(Compile)"
      ItemName="Compile"
      DefaultItemsEnabled="$(EnableDefaultItems)"
      DefaultItemsOfThisTypeEnabled="$(EnableDefaultCompileItems)"
      PropertyNameToDisableDefaultItems="EnableDefaultCompileItems"
      MoreInformationLink="$(DefaultItemsMoreInformationLink)"
      />

    <CheckForDuplicateItems
      Items="@(EmbeddedResource)"
      ItemName="EmbeddedResource"
      DefaultItemsEnabled="$(EnableDefaultItems)"
      DefaultItemsOfThisTypeEnabled="$(EnableDefaultEmbeddedResourceItems)"
      PropertyNameToDisableDefaultItems="EnableDefaultEmbeddedResourceItems"
      MoreInformationLink="$(DefaultItemsMoreInformationLink)"
      />
    
    <!-- TODO: Do we check for duplicate content items here, or in the Web SDK? EnableDefaultContentItems isn't defined or used at all by the .NET SDK -->
    <CheckForDuplicateItems
      Items="@(Content)"
      ItemName="Content"
      DefaultItemsEnabled="$(EnableDefaultItems)"
      DefaultItemsOfThisTypeEnabled="$(EnableDefaultContentItems)"
      PropertyNameToDisableDefaultItems="EnableDefaultContentItems"
      MoreInformationLink="$(DefaultItemsMoreInformationLink)"
      />
    
  </Target>
  
</Project>
