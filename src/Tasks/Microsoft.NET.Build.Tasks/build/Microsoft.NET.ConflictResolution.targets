<!--
***********************************************************************************************
Microsoft.NET.ConflictResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

    <!-- The condition on this target causes it to be skipped during design-time builds if
        the restore operation hasn't run yet.  This is to avoid displaying an error in
        the Visual Studio error list when a project is created before NuGet restore has
        run and created the assets file. -->
  <Target Name="_GetLockFileAssemblies"
          DependsOnTargets="ComputePrivateAssetsPackageReferences;
                            _DefaultMicrosoftNETPlatformLibrary"
          Condition=" '$(DesignTimeBuild)' != 'true' Or Exists('$(ProjectAssetsFile)')">
    <!-- Essentially a copy of the SDKs RunResolvePublishAssemblies.
         We need to find all the files that will be loaded from deps for conflict resolution.
         Note that the RuntimeIdentifier is not passed to this task, as we want to process the
         rid-less assets which will be passed to the compiler.
         -->
    <ResolvePublishAssemblies ProjectPath="$(MSBuildProjectFullPath)"
                              AssetsFilePath="$(ProjectAssetsFile)"
                              TargetFramework="$(TargetFrameworkMoniker)"
                              RuntimeIdentifier=""
                              PlatformLibraryName="$(MicrosoftNETPlatformLibrary)"
                              PrivateAssetsPackageReferences="@(PrivateAssetsPackageReference)">

      <Output TaskParameter="AssembliesToPublish" ItemName="_LockFileAssemblies" />

    </ResolvePublishAssemblies>
  </Target>

  <UsingTask TaskName="HandlePackageFileConflicts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <PropertyGroup>
    <!-- If SelfContained is not true the host will run from packages,
             but we still need to consider those package items for conflicts -->
    <HandlePackageFileConflictsDependsOn Condition="'$(SelfContained)' != 'true'">_GetLockFileAssemblies</HandlePackageFileConflictsDependsOn>
  </PropertyGroup>
  
  <Target Name="HandlePackageFileConflicts" AfterTargets="ResolvePackageDependenciesForBuild" DependsOnTargets="$(HandlePackageFileConflictsDependsOn)">
    <HandlePackageFileConflicts References="@(Reference)"
                                ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)"
                                OtherRuntimeItems="@(_LockFileAssemblies)"
                                PlatformManifests="@(PackageConflictPlatformManifests)"
                                PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferencesWithoutConflicts" ItemName="_ReferencesWithoutConflicts" />
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReferenceCopyLocalPathsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_ConflictPackageFiles" />
    </HandlePackageFileConflicts>

    <!-- Replace Reference / ReferenceCopyLocalPaths with the filtered lists.
         We must remove all and include rather than just remove since removal is based
         only on ItemSpec and duplicate ItemSpecs may exist with different metadata 
         (eg: HintPath) -->
    <ItemGroup>
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_ReferencesWithoutConflicts)" />
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
      <ReferenceCopyLocalPaths Include="@(_ReferenceCopyLocalPathsWithoutConflicts)" />
    </ItemGroup>
  </Target>

  <Target Name="HandlePublishFileConflicts" AfterTargets="RunResolvePublishAssemblies">
    <HandlePackageFileConflicts ReferenceCopyLocalPaths="@(ResolvedAssembliesToPublish)"
                                PlatformManifests="@(PackageConflictPlatformManifests)"
                                PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ResolvedAssembliesToPublishWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_PublishConflictPackageFiles" />
    </HandlePackageFileConflicts>
    <ItemGroup>
      <ResolvedAssembliesToPublish Remove="@(ResolvedAssembliesToPublish)" />
      <ResolvedAssembliesToPublish Include="@(_ResolvedAssembliesToPublishWithoutConflicts)" />
    </ItemGroup>
  </Target>

  <Import Project="Microsoft.Packaging.Tools.Trimming.targets" Condition="'$(_supportsTrimming)' == 'true' AND '$(TrimUnusedDependencies)' == 'true'" />
</Project>